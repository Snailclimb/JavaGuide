---
title: Detailed explanation of class loader (key points)
category: Java
tag:
  - JVM
head:
  - - meta
    - name: keywords
      content: Class loader, parent delegation, loading link initialization, custom ClassLoader, ClassPath
  - - meta
    - name: description
      content: An in-depth explanation of the JVM class loading mechanism and parent delegation model, including the loading process and common practices.
---

## Review the class loading process

Before we start introducing class loaders and the parent delegation model, let's briefly review the class loading process.

- Class loading process: **Loading->Connection->Initialization**.
- The connection process can be divided into three steps: **Verification->Preparation->Analysis**.

![Class loading process](https://oss.javaguide.cn/github/javaguide/java/jvm/class-loading-procedure.png)

Loading is the first step in the class loading process, which mainly completes the following three things:

1. Get the binary byte stream that defines this class through the full class name
2. Convert the static storage structure represented by the byte stream into the runtime data structure of the method area
3. Generate a `Class` object representing the class in memory as the access point for these data in the method area.

## Class loader

### Class loader introduction

Class loaders have appeared since JDK 1.0, originally just to meet the needs of Java Applets (which have been obsolete). Later, it gradually became an important part of Java programs, giving Java classes the ability to be dynamically loaded into the JVM and executed.

According to the official API documentation:

> A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a "class file" of that name from a file system.
>
> Every Class object contains a reference to the ClassLoader that defined it.
>
> Class objects for array classes are not created by class loaders, but are created automatically as required by the Java runtime. The class loader for an array class, as returned by Class.getClassLoader() is the same as the class loader for its element type; if the element type is a primitive type, then the array class has no class loader.

Translated, it roughly means:

> A class loader is an object responsible for loading classes. `ClassLoader` is an abstract class. Given the binary name of a class, the class loader should attempt to locate or generate the data that constitutes the class definition. A typical strategy is to convert the name to a filename and then read a "class file" of that name from the file system.
>
> Every Java class has a reference to the `ClassLoader` that loaded it. However, the array class is not created through `ClassLoader`, but is automatically created by the JVM when needed. When the array class obtains `ClassLoader` through the `getClassLoader()` method, it is consistent with the `ClassLoader` of the element type of the array.

It can be seen from the above introduction:

- A class loader is an object responsible for loading classes and is used to implement the loading step in the class loading process.
- Every Java class has a reference to the `ClassLoader` that loaded it.
- The array class is not created through `ClassLoader` (the array class does not have a corresponding binary byte stream), but is directly generated by the JVM.

```java
class Class<T> {
  ...
  private final ClassLoader classLoader;
  @CallerSensitive
  public ClassLoader getClassLoader() {
     //...
  }
  ...
}
```

Simply put, the main function of the class loader is to dynamically load the bytecode of the Java class (`.class` file) into the JVM (generate a `Class` object representing the class in memory). ** Bytecode can be a Java source program (`.java` file) compiled by `javac`, or it can be dynamically generated by a tool or downloaded from the Internet.

In fact, in addition to loading classes, the class loader can also load resources required by Java applications such as text, images, configuration files, videos, and other file resources. This article only discusses its core function: loading classes.

### Class loader loading rules

When the JVM starts, it does not load all classes at once, but dynamically loads them as needed. In other words, most classes will only be loaded when they are specifically used, which is more memory-friendly.

Loaded classes will be placed in `ClassLoader`. When loading a class, the system will first determine whether the current class has been loaded. Classes that have been loaded will be returned directly, otherwise loading will be attempted. In other words, for a class loader, classes with the same binary name will only be loaded once.

```java
public abstract class ClassLoader {
  ...
  private final ClassLoader parent;
  // Classes loaded by this classloader.
  private final Vector<Class<?>> classes = new Vector<>();
  // Called by the VM to record each loaded class with this class loader.
  void addClass(Class<?> c) {
        classes.addElement(c);
   }
  ...
}
```

### Class loader summary

There are three important `ClassLoaders` built into the JVM:

1. **`BootstrapClassLoader`**: The top-level loading class, implemented by C++, usually expressed as null, and has no parent. It is mainly used to load the core class library inside the JDK (`rt.jar`, `resources.jar`, `charsets.jar` and other jar packages and classes in the `%JAVA_HOME%/lib` directory) as well as the All classes under the path specified by the `-Xbootclasspath` parameter.
2. **`ExtensionClassLoader` (Extension Class Loader)**: Mainly responsible for loading jar packages and classes in the `%JRE_HOME%/lib/ext` directory and all classes in the path specified by the `java.ext.dirs` system variable.
3. **`AppClassLoader` (Application Class Loader)**: A loader for our users, responsible for loading all jar packages and classes under the current application classpath.

> ğŸŒˆ Expand it:
>
> - **`rt.jar`**: rt stands for "RunTime", `rt.jar` is the Java basic class library, containing class files of all classes seen in Java doc. In other words, our commonly used built-in libraries `java.xxx.*` are all in it, such as `java.util.*`, `java.io.*`, `java.nio.*`, `java.lang.*`, `java.sql.*`, `java.math.*`.
> - Java 9 introduced the module system and slightly changed the class loader mentioned above. The extension class loader was renamed the platform class loader. Except for a few key modules in Java SE, such as `java.base`, which are loaded by the startup class loader, other modules are loaded by the platform class loader.

In addition to these three class loaders, users can also add custom class loaders for expansion to meet their own special needs. For example, we can encrypt the bytecode of a Java class (`.class` file) and then use a custom class loader to decrypt it when loading.

![Class loader hierarchy diagram](https://oss.javaguide.cn/github/javaguide/java/jvm/class-loader-parents-delegation-model.png)

Except for `BootstrapClassLoader` which is part of the JVM itself, all other class loaders are implemented outside the JVM and all inherit from the `ClassLoader` abstract class. The advantage of this is that users can customize the class loader so that the application can decide how to obtain the required classes.æ¯ä¸ª `ClassLoader` å¯ä»¥é€šè¿‡`getParent()`è·å–å…¶çˆ¶ `ClassLoader`ï¼Œå¦‚æœè·å–åˆ° `ClassLoader` ä¸º`null`çš„è¯ï¼Œé‚£ä¹ˆè¯¥ç±»åŠ è½½å™¨çš„çˆ¶ç±»åŠ è½½å™¨æ˜¯ `BootstrapClassLoader` ã€‚

```java
public abstract class ClassLoader {
  ...
  // çˆ¶åŠ è½½å™¨
  private final ClassLoader parent;
  @CallerSensitive
  public final ClassLoader getParent() {
     //...
  }
  ...
}
```

**ä¸ºä»€ä¹ˆ è·å–åˆ° `ClassLoader` ä¸º`null`å°±æ˜¯ `BootstrapClassLoader` åŠ è½½çš„å‘¢ï¼Ÿ** è¿™æ˜¯å› ä¸º`BootstrapClassLoader` ç”± C++ å®ç°ï¼Œç”±äºè¿™ä¸ª C++ å®ç°çš„ç±»åŠ è½½å™¨åœ¨ Java ä¸­æ˜¯æ²¡æœ‰ä¸ä¹‹å¯¹åº”çš„ç±»çš„ï¼Œæ‰€ä»¥æ‹¿åˆ°çš„ç»“æœæ˜¯ nullã€‚

ä¸‹é¢æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªè·å– `ClassLoader` çš„å°æ¡ˆä¾‹ï¼š

```java
public class PrintClassLoaderTree {

    public static void main(String[] args) {

        ClassLoader classLoader = PrintClassLoaderTree.class.getClassLoader();

        StringBuilder split = new StringBuilder("|--");
        boolean needContinue = true;
        while (needContinue){
            System.out.println(split.toString() + classLoader);
            if(classLoader == null){
                needContinue = false;
            }else{
                classLoader = classLoader.getParent();
                split.insert(0, "\t");
            }
        }
    }

}
```

è¾“å‡ºç»“æœ(JDK 8 )ï¼š

```plain
|--sun.misc.Launcher$AppClassLoader@18b4aac2
    |--sun.misc.Launcher$ExtClassLoader@53bd815b
        |--null
```

ä»è¾“å‡ºç»“æœå¯ä»¥çœ‹å‡ºï¼š

- æˆ‘ä»¬ç¼–å†™çš„ Java ç±» `PrintClassLoaderTree` çš„ `ClassLoader` æ˜¯`AppClassLoader`ï¼›
- `AppClassLoader`çš„çˆ¶ `ClassLoader` æ˜¯`ExtClassLoader`ï¼›
- `ExtClassLoader`çš„çˆ¶`ClassLoader`æ˜¯`Bootstrap ClassLoader`ï¼Œå› æ­¤è¾“å‡ºç»“æœä¸º nullã€‚

### è‡ªå®šä¹‰ç±»åŠ è½½å™¨

æˆ‘ä»¬å‰é¢ä¹Ÿè¯´è¯´äº†ï¼Œé™¤äº† `BootstrapClassLoader` å…¶ä»–ç±»åŠ è½½å™¨å‡ç”± Java å®ç°ä¸”å…¨éƒ¨ç»§æ‰¿è‡ª`java.lang.ClassLoader`ã€‚å¦‚æœæˆ‘ä»¬è¦è‡ªå®šä¹‰è‡ªå·±çš„ç±»åŠ è½½å™¨ï¼Œå¾ˆæ˜æ˜¾éœ€è¦ç»§æ‰¿ `ClassLoader`æŠ½è±¡ç±»ã€‚

`ClassLoader` ç±»æœ‰ä¸¤ä¸ªå…³é”®çš„æ–¹æ³•ï¼š

- `protected Class loadClass(String name, boolean resolve)`ï¼šåŠ è½½æŒ‡å®šäºŒè¿›åˆ¶åç§°çš„ç±»ï¼Œå®ç°äº†åŒäº²å§”æ´¾æœºåˆ¶ ã€‚`name` ä¸ºç±»çš„äºŒè¿›åˆ¶åç§°ï¼Œ`resolve` å¦‚æœä¸º trueï¼Œåœ¨åŠ è½½æ—¶è°ƒç”¨ `resolveClass(Class<?> c)` æ–¹æ³•è§£æè¯¥ç±»ã€‚
- `protected Class findClass(String name)`ï¼šæ ¹æ®ç±»çš„äºŒè¿›åˆ¶åç§°æ¥æŸ¥æ‰¾ç±»ï¼Œé»˜è®¤å®ç°æ˜¯ç©ºæ–¹æ³•ã€‚

å®˜æ–¹ API æ–‡æ¡£ä¸­å†™åˆ°ï¼š

> Subclasses of `ClassLoader` are encouraged to override `findClass(String name)`, rather than this method.
>
> å»ºè®® `ClassLoader`çš„å­ç±»é‡å†™ `findClass(String name)`æ–¹æ³•è€Œä¸æ˜¯`loadClass(String name, boolean resolve)` æ–¹æ³•ã€‚

å¦‚æœæˆ‘ä»¬ä¸æƒ³æ‰“ç ´åŒäº²å§”æ´¾æ¨¡å‹ï¼Œå°±é‡å†™ `ClassLoader` ç±»ä¸­çš„ `findClass()` æ–¹æ³•å³å¯ï¼Œæ— æ³•è¢«çˆ¶ç±»åŠ è½½å™¨åŠ è½½çš„ç±»æœ€ç»ˆä¼šé€šè¿‡è¿™ä¸ªæ–¹æ³•è¢«åŠ è½½ã€‚ä½†æ˜¯ï¼Œå¦‚æœæƒ³æ‰“ç ´åŒäº²å§”æ´¾æ¨¡å‹åˆ™éœ€è¦é‡å†™ `loadClass()` æ–¹æ³•ã€‚

## åŒäº²å§”æ´¾æ¨¡å‹

### åŒäº²å§”æ´¾æ¨¡å‹ä»‹ç»

ç±»åŠ è½½å™¨æœ‰å¾ˆå¤šç§ï¼Œå½“æˆ‘ä»¬æƒ³è¦åŠ è½½ä¸€ä¸ªç±»çš„æ—¶å€™ï¼Œå…·ä½“æ˜¯å“ªä¸ªç±»åŠ è½½å™¨åŠ è½½å‘¢ï¼Ÿè¿™å°±éœ€è¦æåˆ°åŒäº²å§”æ´¾æ¨¡å‹äº†ã€‚

æ ¹æ®å®˜ç½‘ä»‹ç»ï¼š

> The ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine's built-in class loader, called the "bootstrap class loader", does not itself have a parent but may serve as the parent of a ClassLoader instance.

ç¿»è¯‘è¿‡æ¥å¤§æ¦‚çš„æ„æ€æ˜¯ï¼š

> `ClassLoader` ç±»ä½¿ç”¨å§”æ‰˜æ¨¡å‹æ¥æœç´¢ç±»å’Œèµ„æºã€‚æ¯ä¸ª `ClassLoader` å®ä¾‹éƒ½æœ‰ä¸€ä¸ªç›¸å…³çš„çˆ¶ç±»åŠ è½½å™¨ã€‚éœ€è¦æŸ¥æ‰¾ç±»æˆ–èµ„æºæ—¶ï¼Œ`ClassLoader` å®ä¾‹ä¼šåœ¨è¯•å›¾äº²è‡ªæŸ¥æ‰¾ç±»æˆ–èµ„æºä¹‹å‰ï¼Œå°†æœç´¢ç±»æˆ–èµ„æºçš„ä»»åŠ¡å§”æ‰˜ç»™å…¶çˆ¶ç±»åŠ è½½å™¨ã€‚
> è™šæ‹Ÿæœºä¸­è¢«ç§°ä¸º "bootstrap class loader"çš„å†…ç½®ç±»åŠ è½½å™¨æœ¬èº«æ²¡æœ‰çˆ¶ç±»åŠ è½½å™¨ï¼Œä½†æ˜¯å¯ä»¥ä½œä¸º `ClassLoader` å®ä¾‹çš„çˆ¶ç±»åŠ è½½å™¨ã€‚

ä»ä¸Šé¢çš„ä»‹ç»å¯ä»¥çœ‹å‡ºï¼š

- `ClassLoader` ç±»ä½¿ç”¨å§”æ‰˜æ¨¡å‹æ¥æœç´¢ç±»å’Œèµ„æºã€‚
- åŒäº²å§”æ´¾æ¨¡å‹è¦æ±‚é™¤äº†é¡¶å±‚çš„å¯åŠ¨ç±»åŠ è½½å™¨å¤–ï¼Œå…¶ä½™çš„ç±»åŠ è½½å™¨éƒ½åº”æœ‰è‡ªå·±çš„çˆ¶ç±»åŠ è½½å™¨ã€‚
- `ClassLoader` å®ä¾‹ä¼šåœ¨è¯•å›¾äº²è‡ªæŸ¥æ‰¾ç±»æˆ–èµ„æºä¹‹å‰ï¼Œå°†æœç´¢ç±»æˆ–èµ„æºçš„ä»»åŠ¡å§”æ‰˜ç»™å…¶çˆ¶ç±»åŠ è½½å™¨ã€‚

ä¸‹å›¾å±•ç¤ºçš„å„ç§ç±»åŠ è½½å™¨ä¹‹é—´çš„å±‚æ¬¡å…³ç³»è¢«ç§°ä¸ºç±»åŠ è½½å™¨çš„â€œ**åŒäº²å§”æ´¾æ¨¡å‹(Parents Delegation Model)**â€ã€‚

![ç±»åŠ è½½å™¨å±‚æ¬¡å…³ç³»å›¾](https://oss.javaguide.cn/github/javaguide/java/jvm/class-loader-parents-delegation-model.png)

æ³¨æ„ âš ï¸ï¼šåŒäº²å§”æ´¾æ¨¡å‹å¹¶ä¸æ˜¯ä¸€ç§å¼ºåˆ¶æ€§çš„çº¦æŸï¼Œåªæ˜¯ JDK å®˜æ–¹æ¨èçš„ä¸€ç§æ–¹å¼ã€‚å¦‚æœæˆ‘ä»¬å› ä¸ºæŸäº›ç‰¹æ®Šéœ€æ±‚æƒ³è¦æ‰“ç ´åŒäº²å§”æ´¾æ¨¡å‹ï¼Œä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œåæ–‡ä¼šä»‹ç»å…·ä½“çš„æ–¹æ³•ã€‚

å…¶å®è¿™ä¸ªåŒäº²ç¿»è¯‘çš„å®¹æ˜“è®©åˆ«äººè¯¯è§£ï¼Œæˆ‘ä»¬ä¸€èˆ¬ç†è§£çš„åŒäº²éƒ½æ˜¯çˆ¶æ¯ï¼Œè¿™é‡Œçš„åŒäº²æ›´å¤šåœ°è¡¨è¾¾çš„æ˜¯â€œçˆ¶æ¯è¿™ä¸€è¾ˆâ€çš„äººè€Œå·²ï¼Œå¹¶ä¸æ˜¯è¯´çœŸçš„æœ‰ä¸€ä¸ª `MotherClassLoader` å’Œä¸€ä¸ª`FatherClassLoader` ã€‚ä¸ªäººè§‰å¾—ç¿»è¯‘æˆå•äº²å§”æ´¾æ¨¡å‹æ›´å¥½ä¸€äº›ï¼Œä¸è¿‡ï¼Œå›½å†…æ—¢ç„¶ç¿»è¯‘æˆäº†åŒäº²å§”æ´¾æ¨¡å‹å¹¶æµä¼ äº†ï¼ŒæŒ‰ç…§è¿™ä¸ªæ¥ä¹Ÿæ²¡é—®é¢˜ï¼Œä¸è¦è¢«è¯¯è§£äº†å°±å¥½ã€‚

å¦å¤–ï¼Œç±»åŠ è½½å™¨ä¹‹é—´çš„çˆ¶å­å…³ç³»ä¸€èˆ¬ä¸æ˜¯ä»¥ç»§æ‰¿çš„å…³ç³»æ¥å®ç°çš„ï¼Œè€Œæ˜¯é€šå¸¸ä½¿ç”¨ç»„åˆå…³ç³»æ¥å¤ç”¨çˆ¶åŠ è½½å™¨çš„ä»£ç ã€‚

```java
public abstract class ClassLoader {
  ...
  // ç»„åˆ
  private final ClassLoader parent;
  protected ClassLoader(ClassLoader parent) {
       this(checkCreateClassLoader(), parent);
  }
  ...
}
```

åœ¨é¢å‘å¯¹è±¡ç¼–ç¨‹ä¸­ï¼Œæœ‰ä¸€æ¡éå¸¸ç»å…¸çš„è®¾è®¡åŸåˆ™ï¼š**ç»„åˆä¼˜äºç»§æ‰¿ï¼Œå¤šç”¨ç»„åˆå°‘ç”¨ç»§æ‰¿ã€‚**

### åŒäº²å§”æ´¾æ¨¡å‹çš„æ‰§è¡Œæµç¨‹

åŒäº²å§”æ´¾æ¨¡å‹çš„å®ç°ä»£ç éå¸¸ç®€å•ï¼Œé€»è¾‘éå¸¸æ¸…æ™°ï¼Œéƒ½é›†ä¸­åœ¨ `java.lang.ClassLoader` çš„ `loadClass()` ä¸­ï¼Œç›¸å…³ä»£ç å¦‚ä¸‹æ‰€ç¤ºã€‚

```java
protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        //é¦–å…ˆï¼Œæ£€æŸ¥è¯¥ç±»æ˜¯å¦å·²ç»åŠ è½½è¿‡
        Class c = findLoadedClass(name);
        if (c == null) {
            //å¦‚æœ c ä¸º nullï¼Œåˆ™è¯´æ˜è¯¥ç±»æ²¡æœ‰è¢«åŠ è½½è¿‡
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    //å½“çˆ¶ç±»çš„åŠ è½½å™¨ä¸ä¸ºç©ºï¼Œåˆ™é€šè¿‡çˆ¶ç±»çš„loadClassæ¥åŠ è½½è¯¥ç±»
                    c = parent.loadClass(name, false);
                } else {
                    //å½“çˆ¶ç±»çš„åŠ è½½å™¨ä¸ºç©ºï¼Œåˆ™è°ƒç”¨å¯åŠ¨ç±»åŠ è½½å™¨æ¥åŠ è½½è¯¥ç±»
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                //éç©ºçˆ¶ç±»çš„ç±»åŠ è½½å™¨æ— æ³•æ‰¾åˆ°ç›¸åº”çš„ç±»ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸
            }

            if (c == null) {
                //å½“çˆ¶ç±»åŠ è½½å™¨æ— æ³•åŠ è½½æ—¶ï¼Œåˆ™è°ƒç”¨findClassæ–¹æ³•æ¥åŠ è½½è¯¥ç±»
                //ç”¨æˆ·å¯é€šè¿‡è¦†å†™è¯¥æ–¹æ³•ï¼Œæ¥è‡ªå®šä¹‰ç±»åŠ è½½å™¨
                long t1 = System.nanoTime();
                c = findClass(name);

                //ç”¨äºç»Ÿè®¡ç±»åŠ è½½å™¨ç›¸å…³çš„ä¿¡æ¯
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            //å¯¹ç±»è¿›è¡Œlinkæ“ä½œ
            resolveClass(c);
        }
        return c;
    }
}
```

æ¯å½“ä¸€ä¸ªç±»åŠ è½½å™¨æ¥æ”¶åˆ°åŠ è½½è¯·æ±‚æ—¶ï¼Œå®ƒä¼šå…ˆå°†è¯·æ±‚è½¬å‘ç»™çˆ¶ç±»åŠ è½½å™¨ã€‚åœ¨çˆ¶ç±»åŠ è½½å™¨æ²¡æœ‰æ‰¾åˆ°æ‰€è¯·æ±‚çš„ç±»çš„æƒ…å†µä¸‹ï¼Œè¯¥ç±»åŠ è½½å™¨æ‰ä¼šå°è¯•å»åŠ è½½ã€‚

ç»“åˆä¸Šé¢çš„æºç ï¼Œç®€å•æ€»ç»“ä¸€ä¸‹åŒäº²å§”æ´¾æ¨¡å‹çš„æ‰§è¡Œæµç¨‹ï¼š

- åœ¨ç±»åŠ è½½çš„æ—¶å€™ï¼Œç³»ç»Ÿä¼šé¦–å…ˆåˆ¤æ–­å½“å‰ç±»æ˜¯å¦è¢«åŠ è½½è¿‡ã€‚å·²ç»è¢«åŠ è½½çš„ç±»ä¼šç›´æ¥è¿”å›ï¼Œå¦åˆ™æ‰ä¼šå°è¯•åŠ è½½ï¼ˆæ¯ä¸ªçˆ¶ç±»åŠ è½½å™¨éƒ½ä¼šèµ°ä¸€éè¿™ä¸ªæµç¨‹ï¼‰ã€‚
- ç±»åŠ è½½å™¨åœ¨è¿›è¡Œç±»åŠ è½½çš„æ—¶å€™ï¼Œå®ƒé¦–å…ˆä¸ä¼šè‡ªå·±å»å°è¯•åŠ è½½è¿™ä¸ªç±»ï¼Œè€Œæ˜¯æŠŠè¿™ä¸ªè¯·æ±‚å§”æ´¾ç»™çˆ¶ç±»åŠ è½½å™¨å»å®Œæˆï¼ˆè°ƒç”¨çˆ¶åŠ è½½å™¨ `loadClass()`æ–¹æ³•æ¥åŠ è½½ç±»ï¼‰ã€‚è¿™æ ·çš„è¯ï¼Œæ‰€æœ‰çš„è¯·æ±‚æœ€ç»ˆéƒ½ä¼šä¼ é€åˆ°é¡¶å±‚çš„å¯åŠ¨ç±»åŠ è½½å™¨ `BootstrapClassLoader` ä¸­ã€‚
- åªæœ‰å½“çˆ¶åŠ è½½å™¨åé¦ˆè‡ªå·±æ— æ³•å®Œæˆè¿™ä¸ªåŠ è½½è¯·æ±‚ï¼ˆå®ƒçš„æœç´¢èŒƒå›´ä¸­æ²¡æœ‰æ‰¾åˆ°æ‰€éœ€çš„ç±»ï¼‰æ—¶ï¼Œå­åŠ è½½å™¨æ‰ä¼šå°è¯•è‡ªå·±å»åŠ è½½ï¼ˆè°ƒç”¨è‡ªå·±çš„ `findClass()` æ–¹æ³•æ¥åŠ è½½ç±»ï¼‰ã€‚
- å¦‚æœå­ç±»åŠ è½½å™¨ä¹Ÿæ— æ³•åŠ è½½è¿™ä¸ªç±»ï¼Œé‚£ä¹ˆå®ƒä¼šæŠ›å‡ºä¸€ä¸ª `ClassNotFoundException` å¼‚å¸¸ã€‚

ğŸŒˆ æ‹“å±•ä¸€ä¸‹ï¼š

**JVM åˆ¤å®šä¸¤ä¸ª Java ç±»æ˜¯å¦ç›¸åŒçš„å…·ä½“è§„åˆ™**ï¼šJVM ä¸ä»…è¦çœ‹ç±»çš„å…¨åæ˜¯å¦ç›¸åŒï¼Œè¿˜è¦çœ‹åŠ è½½æ­¤ç±»çš„ç±»åŠ è½½å™¨æ˜¯å¦ä¸€æ ·ã€‚åªæœ‰ä¸¤è€…éƒ½ç›¸åŒçš„æƒ…å†µï¼Œæ‰è®¤ä¸ºä¸¤ä¸ªç±»æ˜¯ç›¸åŒçš„ã€‚å³ä½¿ä¸¤ä¸ªç±»æ¥æºäºåŒä¸€ä¸ª `Class` æ–‡ä»¶ï¼Œè¢«åŒä¸€ä¸ªè™šæ‹ŸæœºåŠ è½½ï¼Œåªè¦åŠ è½½å®ƒä»¬çš„ç±»åŠ è½½å™¨ä¸åŒï¼Œé‚£è¿™ä¸¤ä¸ªç±»å°±å¿…å®šä¸ç›¸åŒã€‚

### åŒäº²å§”æ´¾æ¨¡å‹çš„å¥½å¤„

åŒäº²å§”æ´¾æ¨¡å‹æ˜¯ Java ç±»åŠ è½½æœºåˆ¶çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œå®ƒé€šè¿‡å§”æ´¾çˆ¶åŠ è½½å™¨ä¼˜å…ˆåŠ è½½ç±»çš„æ–¹å¼ï¼Œå®ç°äº†ä¸¤ä¸ªå…³é”®çš„å®‰å…¨ç›®æ ‡ï¼šé¿å…ç±»çš„é‡å¤åŠ è½½å’Œé˜²æ­¢æ ¸å¿ƒ API è¢«ç¯¡æ”¹ã€‚

JVM åŒºåˆ†ä¸åŒç±»çš„ä¾æ®æ˜¯ç±»ååŠ ä¸ŠåŠ è½½è¯¥ç±»çš„ç±»åŠ è½½å™¨ï¼Œå³ä½¿ç±»åç›¸åŒï¼Œå¦‚æœç”±ä¸åŒçš„ç±»åŠ è½½å™¨åŠ è½½ï¼Œä¹Ÿä¼šè¢«è§†ä¸ºä¸åŒçš„ç±»ã€‚ åŒäº²å§”æ´¾æ¨¡å‹ç¡®ä¿æ ¸å¿ƒç±»æ€»æ˜¯ç”± `BootstrapClassLoader` åŠ è½½ï¼Œä¿è¯äº†æ ¸å¿ƒç±»çš„å”¯ä¸€æ€§ã€‚

ä¾‹å¦‚ï¼Œå½“åº”ç”¨ç¨‹åºå°è¯•åŠ è½½ `java.lang.Object` æ—¶ï¼Œ`AppClassLoader` ä¼šé¦–å…ˆå°†è¯·æ±‚å§”æ´¾ç»™ `ExtClassLoader`ï¼Œ`ExtClassLoader` å†å§”æ´¾ç»™ `BootstrapClassLoader`ã€‚`BootstrapClassLoader` ä¼šåœ¨ JRE æ ¸å¿ƒç±»åº“ä¸­æ‰¾åˆ°å¹¶åŠ è½½ `java.lang.Object`ï¼Œä»è€Œä¿è¯åº”ç”¨ç¨‹åºä½¿ç”¨çš„æ˜¯ JRE æä¾›çš„æ ‡å‡†ç‰ˆæœ¬ã€‚

æœ‰å¾ˆå¤šå°ä¼™ä¼´å°±è¦è¯´äº†ï¼šâ€œé‚£æˆ‘ç»•è¿‡åŒäº²å§”æ´¾æ¨¡å‹ä¸å°±å¯ä»¥äº†ä¹ˆï¼Ÿâ€ã€‚

ç„¶è€Œï¼Œå³ä½¿æ”»å‡»è€…ç»•è¿‡äº†åŒäº²å§”æ´¾æ¨¡å‹ï¼ŒJava ä»ç„¶å…·å¤‡æ›´åº•å±‚çš„å®‰å…¨æœºåˆ¶æ¥ä¿æŠ¤æ ¸å¿ƒç±»åº“ã€‚`ClassLoader` çš„ `preDefineClass` æ–¹æ³•ä¼šåœ¨å®šä¹‰ç±»ä¹‹å‰è¿›è¡Œç±»åæ ¡éªŒã€‚ä»»ä½•ä»¥ `"java."` å¼€å¤´çš„ç±»åéƒ½ä¼šè§¦å‘ `SecurityException`ï¼Œé˜»æ­¢æ¶æ„ä»£ç å®šä¹‰æˆ–åŠ è½½ä¼ªé€ çš„æ ¸å¿ƒç±»ã€‚

JDK 8 ä¸­`ClassLoader#preDefineClass` æ–¹æ³•æºç å¦‚ä¸‹ï¼š

```java
private ProtectionDomain preDefineClass(String name,
                                            ProtectionDomain pd)
    {
        // æ£€æŸ¥ç±»åæ˜¯å¦åˆæ³•
        if (!checkName(name)) {
            throw new NoClassDefFoundError("IllegalName: " + name);
        }

        // é˜²æ­¢åœ¨ "java.*" åŒ…ä¸­å®šä¹‰ç±»ã€‚
        // æ­¤æ£€æŸ¥å¯¹äºå®‰å…¨æ€§è‡³å…³é‡è¦ï¼Œå› ä¸ºå®ƒå¯ä»¥é˜²æ­¢æ¶æ„ä»£ç æ›¿æ¢æ ¸å¿ƒ Java ç±»ã€‚
        // JDK 9 åˆ©ç”¨å¹³å°ç±»åŠ è½½å™¨å¢å¼ºäº† preDefineClass æ–¹æ³•çš„å®‰å…¨æ€§
        if ((name != null) && name.startsWith("java.")) {
            throw new SecurityException
                ("ç¦æ­¢çš„åŒ…å: " +
                 name.substring(0, name.lastIndexOf('.')));
        }

         // å¦‚æœæœªæŒ‡å®š ProtectionDomainï¼Œåˆ™ä½¿ç”¨é»˜è®¤åŸŸï¼ˆdefaultDomainï¼‰ã€‚
        if (pd == null) {
            pd = defaultDomain;
        }

        if (name != null) {
            checkCerts(name, pd.getCodeSource());
        }

        return pd;
    }
```

JDK 9 ä¸­è¿™éƒ¨åˆ†é€»è¾‘æœ‰æ‰€æ”¹å˜ï¼Œå¤šäº†å¹³å°ç±»åŠ è½½å™¨ï¼ˆ`getPlatformClassLoader()` æ–¹æ³•è·å–ï¼‰ï¼Œå¢å¼ºäº† `preDefineClass` æ–¹æ³•çš„å®‰å…¨æ€§ã€‚è¿™é‡Œå°±ä¸è´´æºç äº†ï¼Œæ„Ÿå…´è¶£çš„è¯ï¼Œå¯ä»¥è‡ªå·±å»çœ‹çœ‹ã€‚

### æ‰“ç ´åŒäº²å§”æ´¾æ¨¡å‹æ–¹æ³•

~~ä¸ºäº†é¿å…åŒäº²å§”æ‰˜æœºåˆ¶ï¼Œæˆ‘ä»¬å¯ä»¥è‡ªå·±å®šä¹‰ä¸€ä¸ªç±»åŠ è½½å™¨ï¼Œç„¶åé‡å†™ `loadClass()` å³å¯ã€‚~~

**ğŸ› ä¿®æ­£ï¼ˆå‚è§ï¼š[issue871](https://github.com/Snailclimb/JavaGuide/issues/871) ï¼‰**ï¼šè‡ªå®šä¹‰åŠ è½½å™¨çš„è¯ï¼Œéœ€è¦ç»§æ‰¿ `ClassLoader` ã€‚å¦‚æœæˆ‘ä»¬ä¸æƒ³æ‰“ç ´åŒäº²å§”æ´¾æ¨¡å‹ï¼Œå°±é‡å†™ `ClassLoader` ç±»ä¸­çš„ `findClass()` æ–¹æ³•å³å¯ï¼Œæ— æ³•è¢«çˆ¶ç±»åŠ è½½å™¨åŠ è½½çš„ç±»æœ€ç»ˆä¼šé€šè¿‡è¿™ä¸ªæ–¹æ³•è¢«åŠ è½½ã€‚ä½†æ˜¯ï¼Œå¦‚æœæƒ³æ‰“ç ´åŒäº²å§”æ´¾æ¨¡å‹åˆ™éœ€è¦é‡å†™ `loadClass()` æ–¹æ³•ã€‚

ä¸ºä»€ä¹ˆæ˜¯é‡å†™ `loadClass()` æ–¹æ³•æ‰“ç ´åŒäº²å§”æ´¾æ¨¡å‹å‘¢ï¼ŸåŒäº²å§”æ´¾æ¨¡å‹çš„æ‰§è¡Œæµç¨‹å·²ç»è§£é‡Šäº†ï¼š

> ç±»åŠ è½½å™¨åœ¨è¿›è¡Œç±»åŠ è½½çš„æ—¶å€™ï¼Œå®ƒé¦–å…ˆä¸ä¼šè‡ªå·±å»å°è¯•åŠ è½½è¿™ä¸ªç±»ï¼Œè€Œæ˜¯æŠŠè¿™ä¸ªè¯·æ±‚å§”æ´¾ç»™çˆ¶ç±»åŠ è½½å™¨å»å®Œæˆï¼ˆè°ƒç”¨çˆ¶åŠ è½½å™¨ `loadClass()`æ–¹æ³•æ¥åŠ è½½ç±»ï¼‰ã€‚

é‡å†™ `loadClass()`æ–¹æ³•ä¹‹åï¼Œæˆ‘ä»¬å°±å¯ä»¥æ”¹å˜ä¼ ç»ŸåŒäº²å§”æ´¾æ¨¡å‹çš„æ‰§è¡Œæµç¨‹ã€‚ä¾‹å¦‚ï¼Œå­ç±»åŠ è½½å™¨å¯ä»¥åœ¨å§”æ´¾ç»™çˆ¶ç±»åŠ è½½å™¨ä¹‹å‰ï¼Œå…ˆè‡ªå·±å°è¯•åŠ è½½è¿™ä¸ªç±»ï¼Œæˆ–è€…åœ¨çˆ¶ç±»åŠ è½½å™¨è¿”å›ä¹‹åï¼Œå†å°è¯•ä»å…¶ä»–åœ°æ–¹åŠ è½½è¿™ä¸ªç±»ã€‚å…·ä½“çš„è§„åˆ™ç”±æˆ‘ä»¬è‡ªå·±å®ç°ï¼Œæ ¹æ®é¡¹ç›®éœ€æ±‚å®šåˆ¶åŒ–ã€‚

æˆ‘ä»¬æ¯”è¾ƒç†Ÿæ‚‰çš„ Tomcat æœåŠ¡å™¨ä¸ºäº†èƒ½å¤Ÿä¼˜å…ˆåŠ è½½ Web åº”ç”¨ç›®å½•ä¸‹çš„ç±»ï¼Œç„¶åå†åŠ è½½å…¶ä»–ç›®å½•ä¸‹çš„ç±»ï¼Œå°±è‡ªå®šä¹‰äº†ç±»åŠ è½½å™¨ `WebAppClassLoader` æ¥æ‰“ç ´åŒäº²å§”æ‰˜æœºåˆ¶ã€‚è¿™ä¹Ÿæ˜¯ Tomcat ä¸‹ Web åº”ç”¨ä¹‹é—´çš„ç±»å®ç°éš”ç¦»çš„å…·ä½“åŸç†ã€‚

Tomcat çš„ç±»åŠ è½½å™¨çš„å±‚æ¬¡ç»“æ„å¦‚ä¸‹ï¼š

![Tomcat çš„ç±»åŠ è½½å™¨çš„å±‚æ¬¡ç»“æ„](https://oss.javaguide.cn/github/javaguide/java/jvm/tomcat-class-loader-parents-delegation-model.png)

Tomcat è¿™å››ä¸ªè‡ªå®šä¹‰çš„ç±»åŠ è½½å™¨å¯¹åº”çš„ç›®å½•å¦‚ä¸‹ï¼š

- `CommonClassLoader`å¯¹åº”`<Tomcat>/common/*`
- `CatalinaClassLoader`å¯¹åº”`<Tomcat >/server/*`
- `SharedClassLoader`å¯¹åº” `<Tomcat >/shared/*`
- `WebAppClassloader`å¯¹åº” `<Tomcat >/webapps/<app>/WEB-INF/*`

ä»å›¾ä¸­çš„å§”æ´¾å…³ç³»ä¸­å¯ä»¥çœ‹å‡ºï¼š

- `CommonClassLoader`ä½œä¸º `CatalinaClassLoader` å’Œ `SharedClassLoader` çš„çˆ¶åŠ è½½å™¨ã€‚`CommonClassLoader` èƒ½åŠ è½½çš„ç±»éƒ½å¯ä»¥è¢« `CatalinaClassLoader` å’Œ `SharedClassLoader` ä½¿ç”¨ã€‚å› æ­¤ï¼Œ`CommonClassLoader` æ˜¯ä¸ºäº†å®ç°å…¬å…±ç±»åº“ï¼ˆå¯ä»¥è¢«æ‰€æœ‰ Web åº”ç”¨å’Œ Tomcat å†…éƒ¨ç»„ä»¶ä½¿ç”¨çš„ç±»åº“ï¼‰çš„å…±äº«å’Œéš”ç¦»ã€‚
- `CatalinaClassLoader` å’Œ `SharedClassLoader` èƒ½åŠ è½½çš„ç±»åˆ™ä¸å¯¹æ–¹ç›¸äº’éš”ç¦»ã€‚`CatalinaClassLoader` ç”¨äºåŠ è½½ Tomcat è‡ªèº«çš„ç±»ï¼Œä¸ºäº†éš”ç¦» Tomcat æœ¬èº«çš„ç±»å’Œ Web åº”ç”¨çš„ç±»ã€‚`SharedClassLoader` ä½œä¸º `WebAppClassLoader` çš„çˆ¶åŠ è½½å™¨ï¼Œä¸“é—¨æ¥åŠ è½½ Web åº”ç”¨ä¹‹é—´å…±äº«çš„ç±»æ¯”å¦‚ Springã€Mybatisã€‚
- æ¯ä¸ª Web åº”ç”¨éƒ½ä¼šåˆ›å»ºä¸€ä¸ªå•ç‹¬çš„ `WebAppClassLoader`ï¼Œå¹¶åœ¨å¯åŠ¨ Web åº”ç”¨çš„çº¿ç¨‹é‡Œè®¾ç½®çº¿ç¨‹çº¿ç¨‹ä¸Šä¸‹æ–‡ç±»åŠ è½½å™¨ä¸º `WebAppClassLoader`ã€‚å„ä¸ª `WebAppClassLoader` å®ä¾‹ä¹‹é—´ç›¸äº’éš”ç¦»ï¼Œè¿›è€Œå®ç° Web åº”ç”¨ä¹‹é—´çš„ç±»éš”ã€‚

å•çº¯ä¾é è‡ªå®šä¹‰ç±»åŠ è½½å™¨æ²¡åŠæ³•æ»¡è¶³æŸäº›åœºæ™¯çš„è¦æ±‚ï¼Œä¾‹å¦‚ï¼Œæœ‰äº›æƒ…å†µä¸‹ï¼Œé«˜å±‚çš„ç±»åŠ è½½å™¨éœ€è¦åŠ è½½ä½å±‚çš„åŠ è½½å™¨æ‰èƒ½åŠ è½½çš„ç±»ã€‚

For example, in SPI, the SPI interface (such as `java.sql.Driver`) is provided by the Java core library and loaded by `BootstrapClassLoader`. SPI implementations (such as `com.mysql.cj.jdbc.Driver`) are provided by third-party vendors, and they are loaded by application class loaders or custom class loaders. By default, a class and its dependent classes are loaded by the same class loader. Therefore, the class loader that loads the SPI interface (`BootstrapClassLoader`) will also be used to load the SPI implementation. According to the parent delegation model, `BootstrapClassLoader` cannot find the SPI implementation class because it cannot delegate to the subclass loader to try to load it.

It should be noted here: Modularity was introduced after JDK 9+, and the JDBC API was split into the `java.sql` module. It is no longer loaded directly by `BootstrapClassLoader`, but loaded by `PlatformClassLoader`.

```java
public class ClassLoaderTest {
    public static void main(String[] args) throws ClassNotFoundException {
        Class<?> clazz = Class.forName("java.sql.Driver");
        ClassLoader loader = clazz.getClassLoader();
        System.out.println("Loader for java.sql.Driver: " + loader);

        // Loader for java.sql.Driver: null in .jdks/corretto-1.8.0_442/bin/java environment

        // In the .jdks/jbr-17.0.12/bin/java environment, it is Loader for java.sql.Driver: jdk.internal.loader.ClassLoaders$PlatformClassLoader@30f39991
    }
}
```

For another example, assume that there is a Spring jar package in our project. Since it is shared between web applications, it will be loaded by `SharedClassLoader` (the web server is Tomcat). Some of Spring's business classes are used in our project, such as implementing the interfaces provided by Spring and using the annotations provided by Spring. Therefore, the class loader that loads Spring (that is, `SharedClassLoader`) will also be used to load these business classes. However, the business classes are in the Web application directory and not in the loading path of `SharedClassLoader`, so `SharedClassLoader` cannot find the business classes and cannot load them.

How to solve this problem? At this time, you need to use **Thread Context Class Loader (`ThreadContextClassLoader`)**.

Take Spring as an example. When Spring needs to load a business class, it does not use its own class loader, but the context class loader of the current thread. Remember what I said above? Each web application will create a separate `WebAppClassLoader` and set the thread context class loader to `WebAppClassLoader` in the thread that starts the web application. This allows the high-level class loader (`SharedClassLoader`) to use the subclass loader (`WebAppClassLoader`) to load business classes, destroying Java's class loading delegation mechanism and allowing applications to use the class loader in reverse.

The principle of the thread context class loader is to save a class loader in thread private data, bind it to the thread, and then take it out and use it when needed. This class loader is usually set by the application or container (such as Tomcat).

`getContextClassLoader()` and `setContextClassLoader(ClassLoader cl)` in `Java.lang.Thread` are used to obtain and set the context class loader of the thread respectively. If not set via `setContextClassLoader(ClassLoader cl)`, the thread will inherit the context class loader of its parent thread.

Spring's code to obtain the thread context class loader is as follows:

```java
cl = Thread.currentThread().getContextClassLoader();
```

Interested friends can delve into the principles of Tomcat breaking the parental delegation model. Recommended information: ["In-depth Disassembly of Tomcat & Jetty"](http://gk.link/a/10Egr).

## Recommended reading

- "In-depth Disassembly of Java Virtual Machine"
- In-depth analysis of Java ClassLoader principles: <https://blog.csdn.net/xyang81/article/details/7292380>
- Java class loader (ClassLoader): <http://gityuan.com/2016/01/24/java-classloader/>
- Class Loaders in Javaï¼š<https://www.baeldung.com/java-classloaders>
- Class ClassLoader - Oracle official documentation: <https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html>
- The old and difficult Java ClassLoader will be old if you donâ€™t understand it anymore: <https://zhuanlan.zhihu.com/p/51374915>

<!-- @include: @article-footer.snippet.md -->