---
title: Detailed explanation of class file structure
category: Java
tag:
  - JVM
head:
  - - meta
    - name: keywords
      content: Class file, constant pool, magic number, version, fields, methods, properties
  - - meta
    - name: description
      content: Introduces core components such as Java bytecode Class file structure and constant pool to assist in understanding compiled products.
---

## Review the bytecode

In Java, the code that the JVM can understand is called bytecode (that is, a file with the extension `.class`). It is not oriented to any specific processor, only to the virtual machine. The Java language solves the problem of low execution efficiency of traditional interpreted languages ​​to a certain extent through bytecode, while retaining the portability characteristics of interpreted languages. Therefore, Java programs run more efficiently, and because the bytecode is not specific to a specific machine, Java programs can run on computers with many different operating systems without recompiling.

Clojure (a dialect of the Lisp language), Groovy, Scala, JRuby, Kotlin and other languages ​​all run on the Java virtual machine. The figure below shows that different languages ​​are compiled into `.class` files by different compilers and finally run on the Java virtual machine. The binary format of `.class` files can be viewed using [WinHex](https://www.x-ways.net/winhex/).

![Programming language running on the Java virtual machine](https://oss.javaguide.cn/github/javaguide/java/basis/java-virtual-machine-program-language-os.png)

It can be said that the `.class` file is an important bridge between different languages ​​in the Java virtual machine, and it is also an important reason to support Java cross-platform.

## Class file structure summary

According to the Java virtual machine specification, Class files are defined through `ClassFile`, which is somewhat similar to the C language structure.

The structure of `ClassFile` is as follows:

```java
ClassFile {
    u4 magic; //Mark of Class file
    u2 minor_version;//Minor version number of Class
    u2 major_version;//The major version number of Class
    u2 constant_pool_count;//The number of constant pools
    cp_info constant_pool[constant_pool_count-1];//Constant pool
    u2 access_flags;//Access flag of Class
    u2 this_class;//Current class
    u2 super_class;//parent class
    u2 interfaces_count;//number of interfaces
    u2 interfaces[interfaces_count];//A class can implement multiple interfaces
    u2 fields_count;//Number of fields
    field_info fields[fields_count];//A class can have multiple fields
    u2 methods_count;//Number of methods
    method_info methods[methods_count];//A class can have multiple methods
    u2 attributes_count;//The number of attributes in this type of attribute table
    attribute_info attributes[attributes_count];//Attribute table collection
}
```

By analyzing the contents of `ClassFile`, we can know the composition of the class file.

![ClassFile content analysis](https://oss.javaguide.cn/java-guide-blog/16d5ec47609818fc.jpeg)

The picture below is viewed through the IDEA plug-in `jclasslib`. You can see the Class file structure more intuitively.

![](https://oss.javaguide.cn/java-guide-blog/image-20210401170711475.png)

Using `jclasslib`, you can not only visually view the bytecode file corresponding to a certain class, but also view the basic information of the class, constant pool, interface, properties, functions and other information.

The following is a detailed introduction to some components involved in the Class file structure.

###Magic Number

```java
    u4 magic; //Mark of Class file
```

The first 4 bytes of each Class file are called the Magic Number. Its only function is to determine whether this file is a Class file that can be received by the virtual machine. The Java specification specifies that the magic number is a fixed value: 0xCAFEBABE. If the file read does not begin with this magic number, the Java virtual machine will refuse to load it.

### Class file version number (Minor&Major Version)

```java
    u2 minor_version;//Minor version number of Class
    u2 major_version;//The major version number of Class
```

The four bytes immediately following the magic number store the version number of the Class file: the 5th and 6th bytes are the **minor version number**, and the 7th and 8th bytes are the **major version number**.

Whenever Java releases a major version (such as Java 8, Java 9), the major version number will be increased by 1. You can use the `javap -v` command to quickly view the version number information of the Class file.

A higher version of the Java virtual machine can execute Class files generated by a lower version of the compiler, but a lower version of the Java virtual machine cannot execute Class files generated by a higher version of the compiler. Therefore, during actual development, we must ensure that the JDK version developed is consistent with the JDK version in the production environment.

### Constant Pool

```java
    u2 constant_pool_count;//The number of constant pools
    cp_info constant_pool[constant_pool_count-1];//Constant pool
```

Immediately after the major and minor version numbers is the constant pool. The number of constant pools is `constant_pool_count-1` (**The constant pool counter starts counting from 1. There are special considerations for emptying the 0th constant. An index value of 0 means "do not reference any constant pool item"**).

The constant pool mainly stores two major constants: literals and symbolic references. Literals are closer to the concept of constants at the Java language level, such as text strings, constant values ​​declared as final, etc. Symbol reference is a concept related to compilation principles. Includes the following three types of constants:

- Fully qualified names of classes and interfaces
- Name and descriptor of the field
- the name and descriptor of the method

Each constant in the constant pool is a table. These 14 tables have a common feature: the first bit at the beginning is a u1 type flag bit -tag to identify the type of the constant, representing which constant type the current constant belongs to. **

| Type | Tag | Description |
| :----------------------------------: | :----------: | :----------------------------------: |
| CONSTANT_utf8_info | 1 | UTF-8 encoded string |
| CONSTANT_Integer_info | 3 | Integer literal |
| CONSTANT_Float_info | 4 | Floating point literal |
| CONSTANT_Long_info | 5 | Long integer literal |
| CONSTANT_Double_info | 6 | Double precision floating point literal |
| CONSTANT_Class_info | 7 | Symbolic reference to a class or interface |
| CONSTANT_String_info | 8 | String type literal |
| CONSTANT_FieldRef_info | 9 | Symbolic reference of field |
| CONSTANT_MethodRef_info | 10 | Symbolic reference to a method in a class |
| CONSTANT_InterfaceMethodRef_info | 11 | Symbolic reference to a method in an interface || CONSTANT_NameAndType_info | 12 | Symbolic reference to a field or method |
| CONSTANT_MethodType_info | 16 | Flag method type |
| CONSTANT_MethodHandle_info | 15 | Represents method handle |
| CONSTANT_InvokeDynamic_info | 18 | Represents a dynamic method call point |

`.class` file can use the `javap -v class class name` command to view the information in its constant pool (`javap -v class class name-> temp.txt`: output the results to the temp.txt file).

### Access Flags

```java
    u2 access_flags;//Access flag of Class
```

After the constant pool ends, the next two bytes represent the access flag. This flag is used to identify some class or interface level access information, including: whether the Class is a class or an interface, whether it is a `public` or `abstract` type, if it is a class, whether it is declared as `final`, etc.

Class access and property modifiers:

![Class access and attribute modifiers](https://oss.javaguide.cn/github/javaguide/java/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png)

We define an `Employee` class

```java
package top.snailclimb.bean;
public class Employee {
   ...
}
```

Use the `javap -v class class name` command to look at the access flags of the class.

![View the access flag of the class](https://oss.javaguide.cn/github/javaguide/java/%E6%9F%A5%E7%9C%8B%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png)

### Index collection of current class (This Class), parent class (Super Class), and interfaces (Interfaces)

```java
    u2 this_class;//Current class
    u2 super_class;//parent class
    u2 interfaces_count;//number of interfaces
    u2 interfaces[interfaces_count];//A class can implement multiple interfaces
```

The inheritance relationship of Java classes is determined by three items: class index, parent class index and interface index set. The class index, parent class index and interface index set are arranged in order after the access flag.

The class index is used to determine the fully qualified name of this class, and the parent class index is used to determine the fully qualified name of the parent class of this class. Due to the single inheritance of the Java language, there is only one parent class index. Except for `java.lang.Object`, all Java classes have parent classes, so except for `java.lang.Object`, the parent class index of all Java classes is not 0.

The interface index collection is used to describe which interfaces this class implements. These implemented interfaces will be arranged in the interface index collection from left to right in the order of the interfaces after `implements` (or `extends` if the class itself is an interface).

### Field table collection (Fields)

```java
    u2 fields_count;//Number of fields
    field_info fields[fields_count];//A class can have a field
```

Field info is used to describe variables declared in an interface or class. Fields include class-level variables and instance variables, but do not include local variables declared within methods.

**Structure of field info (field table):**

![Structure of field table](https://oss.javaguide.cn/github/javaguide/java/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png)

- **access_flags:** The scope of the field (`public`, `private`, `protected` modifiers), whether it is an instance variable or a class variable (`static` modifier), whether it can be serialized (transient modifier), variability (final), visibility (volatile modifier, whether to force reading and writing from main memory).
- **name_index:** A reference to the constant pool, representing the name of the field;
- **descriptor_index:** A reference to the constant pool, representing the descriptors of fields and methods;
- **attributes_count:** A field will also have some additional attributes, attributes_count stores the number of attributes;
- **attributes[attributes_count]:** stores the specific content of specific attributes.

In the above information, each modifier is a Boolean value, either with a certain modifier or without, which is very suitable to be represented by flag bits. The name of the field and the data type for which the field is defined cannot be fixed and can only be described by referring to the constants in the constant pool.

**Value of access_flag of field:**

![The value of the access_flag of the field](https://oss.javaguide.cn/github/javaguide/java/jvm/class-file-fields-access_flag.png)

### Method table collection (Methods)

```java
    u2 methods_count;//Number of methods
    method_info methods[methods_count];//A class can have multiple methods
```

methods_count represents the number of methods, while method_info represents the method table.

The description of methods in the Class file storage format is almost identical to the description of fields. The structure of the method table is the same as the field table, including access flags, name indexes, descriptor indexes, and attribute table collections.

**method_info (method table) structure:**

![Structure of method table](https://oss.javaguide.cn/github/javaguide/java/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png)

**Access_flag value of method table:**

![Access_flag value of method table](https://oss.javaguide.cn/github/javaguide/java/jvm/class-file-methods-access_flag.png)

Note: Because the `volatile` modifier and the `transient` modifier cannot modify methods, there are no corresponding flags in the access flags of the method table. However, keyword modification methods such as `synchronized`, `native`, and `abstract` have been added, so there are more flags corresponding to these keywords.

### Attribute table collection (Attributes)

```java
   u2 attributes_count;//The number of attributes in this type of attribute table
   attribute_info attributes[attributes_count];//Attribute table collection
```

Class files, field tables, and method tables can all carry their own set of attribute tables to describe information specific to certain scenarios. Different from the order, length and content required by other data items in the Class file, the restrictions on the attribute table collection are slightly looser. Each attribute table is no longer required to have a strict order, and as long as it does not duplicate existing attribute names, anyone can implement a compiler to write self-defined attribute information into the attribute table. The Java virtual machine will ignore attributes it does not recognize when running.

## Reference

- "Practical Java Virtual Machine"
- Chapter 4. The class File Format - Java Virtual Machine Specification: <https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html>
- Example analysis of the file structure of JAVA CLASS: <https://coolshell.cn/articles/9229.html>
- "Java Virtual Machine Principle Illustration" 1.2.2, detailed explanation of the constant pool in the Class file (Part 1): <https://blog.csdn.net/luanlouis/article/details/39960815>

<!-- @include: @article-footer.snippet.md -->