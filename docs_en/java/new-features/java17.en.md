---
title: Overview of new features in Java 17 (Important)
category: Java
tag:
  - Java new features
head:
  - - meta
    - name: keywords
      content: Java 17, JDK17, LTS, sealed classes, record classes, pattern matching, API updates, JEP
  - - meta
    - name: description
      content: Summarizes the important updates and JEPs of JDK 17, covering features such as sealed classes, record classes, and pattern matching.
---

Java 17 was officially released on September 14, 2021, and is a long-term support (LTS) version.

The picture below is the official timeline of Oracle JDK support given by Oracle. As you can see, Java

17 is supported until September 2029.

![](https://oss.javaguide.cn/github/javaguide/java/new-features/4c1611fad59449edbbd6e233690e9fa7.png)

Java 17 will be the most important long-term support (LTS) release since Java 8 and is the result of eight years of hard work by the Java community. The minimum supported by Spring 6.x and Spring Boot 3.x is Java 17.

This update brings a total of 14 new features:

- [JEP 306:Restore Always-Strict Floating-Point Semantics (Restore Always-Strict Floating-Point Semantics)](https://openjdk.java.net/jeps/306)
- [JEP 356:Enhanced Pseudo-Random Number Generators (enhanced pseudo-random number generator)](https://openjdk.java.net/jeps/356)
- [JEP 382: New macOS Rendering Pipeline (new macOS rendering pipeline)](https://openjdk.java.net/jeps/382)
- [JEP 391: macOS/AArch64 Port (supports macOS AArch64)](https://openjdk.java.net/jeps/391)
- [JEP 398:Deprecate the Applet API for Removal (remove the deprecated Applet API)](https://openjdk.java.net/jeps/398)
- [JEP 403: Strongly Encapsulate JDK Internals (more powerful encapsulation of JDK internal elements)](https://openjdk.java.net/jeps/403)
- [JEP 406:Pattern Matching for switch (type matching of switch)](https://openjdk.java.net/jeps/406) (Preview)
- [JEP 407:Remove RMI Activation (remove remote method invocation activation mechanism)](https://openjdk.java.net/jeps/407)
- [JEP 409: Sealed Classes (sealed classes)](https://openjdk.java.net/jeps/409) (confirmed)
- [JEP 410:Remove the Experimental AOT and JIT Compiler (remove the experimental AOT and JIT compiler)](https://openjdk.java.net/jeps/410)
- [JEP 411:Deprecate the Security Manager for Removal (deprecate the Security Manager for removal)](https://openjdk.java.net/jeps/411)
- [JEP 412: Foreign Function & Memory API (External Function and Memory API)](https://openjdk.java.net/jeps/412) (Incubation)
- [JEP 414:Vector API](https://openjdk.java.net/jeps/417) (second incubation)
- [JEP 415:Context-Specific Deserialization Filters](https://openjdk.java.net/jeps/415)

Here I will only give a detailed introduction to the new features 356, 398, 413, 406, 407, 409, 410, 411, 412, and 414 that I think are more important.

Related reading: [OpenJDK Java 17 Documentation](https://openjdk.java.net/projects/jdk/17/).

## JEP 356: Enhanced Pseudo-Random Number Generator

Before JDK 17, we could generate random numbers with the help of `Random`, `ThreadLocalRandom` and `SplittableRandom`. However, these three classes have their own flaws and lack support for common pseudo-random algorithms.

Java 17 adds new interface types and implementations for pseudorandom number generators (PRNG, also known as deterministic random bit generators), making it easier for developers to use various PRNG algorithms interchangeably in applications.

> [PRNG](https://ctf-wiki.org/crypto/streamcipher/prng/intro/) is used to generate a number sequence that is close to an absolutely random number sequence. Generally speaking, PRNG relies on an initial value, also called a seed, to generate the corresponding pseudo-random number sequence. As long as the seed is determined, the random numbers generated by PRNG are completely deterministic, so the random number sequence it generates is not truly random.

Usage example:

```java
RandomGeneratorFactory<RandomGenerator> l128X256MixRandom = RandomGeneratorFactory.of("L128X256MixRandom");
// Use timestamp as random number seed
RandomGenerator randomGenerator = l128X256MixRandom.create(System.currentTimeMillis());
// Generate random numbers
randomGenerator.nextInt(10);
```

## JEP 398: Deprecating Applet API for removal

The Applet API, used for writing Java applets that run on the web browser side, was deprecated many years ago and there is no reason to use it anymore.

The Applet API was marked deprecated in Java 9 ([JEP 289](https://openjdk.java.net/jeps/289)), but not for removal.

## JEP 406: Type matching for switch (preview)

Just like `instanceof`, `switch` also adds automatic conversion function for type matching.

`instanceof` code example:

```java
// Old code
if (o instanceof String) {
    String s = (String)o;
    ... use s ...
}

//New code
if (o instanceof String s) {
    ... use s ...
}
```

`switch` code example:

```java
// Old code
static String formatter(Object o) {
    String formatted = "unknown";
    if (o instanceof Integer i) {
        formatted = String.format("int %d", i);
    } else if (o instanceof Long l) {
        formatted = String.format("long %d", l);
    } else if (o instanceof Double d) {
        formatted = String.format("double %f", d);
    } else if (o instanceof String s) {
        formatted = String.format("String %s", s);
    }
    return formatted;
}

//New code
static String formatterPatternSwitch(Object o) {
    return switch (o) {
        case Integer i -> String.format("int %d", i);
        case Long l -> String.format("long %d", l);
        case Double d -> String.format("double %f", d);
        case String s -> String.format("String %s", s);
        default -> o.toString();
    };
}

```The judgment of `null` values ​​has also been optimized.

```java
// Old code
static void testFooBar(String s) {
    if (s == null) {
        System.out.println("oops!");
        return;
    }
    switch (s) {
        case "Foo", "Bar" -> System.out.println("Great");
        default -> System.out.println("Ok");
    }
}

//New code
static void testFooBar(String s) {
    switch (s) {
        case null -> System.out.println("Oops");
        case "Foo", "Bar" -> System.out.println("Great");
        default -> System.out.println("Ok");
    }
}
```

## JEP 407: Remove remote method invocation activation mechanism

Removes the Remote Method Invocation (RMI) activation mechanism while preserving the remainder of RMI. The RMI activation mechanism is obsolete and no longer used.

## JEP 409: Sealed Class (Regularized)

Sealed classes were previewed by [JEP 360](https://openjdk.java.net/jeps/360) and integrated into Java 15. In JDK 16, sealed classes have been improved (stricter reference checking and inheritance relationships of sealed classes), and are previewed again by [JEP 397](https://openjdk.java.net/jeps/397).

In [Java 14 & 15 New Features Overview](./java14-15.md), I have introduced the sealed class in detail, so I will not give any additional introduction here.

## JEP 410: Remove experimental AOT and JIT compilers

In [JEP 295](https://openjdk.java.net/jeps/295) for Java 9, an experimental ahead-of-time (AOT) compiler was introduced to compile Java classes into native code before starting the virtual machine.

Java 17, remove the experimental ahead-of-time (AOT) and just-in-time (JIT) compiler because the compiler has been rarely used since its introduction and the effort required to maintain it is significant. The experimental Java-level JVM Compiler Interface (JVMCI) is retained so that developers can continue to use externally built versions of the compiler for JIT compilation.

## JEP 411: Security manager deprecated for removal

The security manager is deprecated for removal in a future release.

Security Manager dates back to Java 1.0, and over the years it has not been the primary method of protecting client-side Java code, and is rarely used to protect server-side code. To move Java forward, Java 17 deprecates the security manager to be removed along with the legacy Applet API ( [JEP 398](https://openjdk.java.net/jeps/398) ).

## JEP 412: External Functions and Memory API (Incubation)

This API allows Java programs to interoperate with code and data outside the Java runtime. By efficiently calling external functions (i.e., code outside the JVM) and safely accessing external memory (i.e., memory not managed by the JVM), the API enables Java programs to call native libraries and manipulate native data without the dangers and brittleness of JNI.

The external functions and memory API had its first incubation in Java 17, proposed by [JEP 412](https://openjdk.java.net/jeps/412). The second incubation was proposed by [JEP 419](https://openjdk.org/jeps/419) and integrated into Java 18, and the preview was proposed by [JEP 424](https://openjdk.org/jeps/424) and integrated into Java 19.

In [Java 19 New Features Overview](./java19.md), I have introduced external functions and memory API in detail, so I will not give additional introduction here.

## JEP 414: Vector API (Second Incubation)

The Vector API was originally proposed by [JEP 338](https://openjdk.java.net/jeps/338) and integrated into Java 16 as an [Incubation API](http://openjdk.java.net/jeps/11). The second round of incubation was proposed by [JEP 414](https://openjdk.java.net/jeps/414) and integrated into Java 17, the third round of incubation was proposed by [JEP 417](https://openjdk.java.net/jeps/417) and integrated into Java 18, and the fourth round was proposed by [JEP 426](https://openjdk.java.net/jeps/426) Proposed and integrated into Java 19.

The Incubator API provides an initial iteration of an API to express a number of vector computations that are reliably compiled at runtime into the best vector hardware instructions on supported CPU architectures, resulting in better performance than equivalent scalar computations, taking full advantage of Single Instruction Multiple Data (SIMD) technology, an instruction available on most modern CPUs. Although HotSpot supports auto-vectorization, the set of convertible scalar operations is limited and susceptible to code changes. The API will enable developers to easily write portable, high-performance vector algorithms in Java.

In [Java 18 New Features Overview](./java18.md), I introduced the vector API in detail, so I won’t give any additional introduction here.

<!-- @include: @article-footer.snippet.md -->