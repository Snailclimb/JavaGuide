---
title: Overview of new features in Java 14 & 15
category: Java
tag:
  - Java new features
head:
  - - meta
    - name: keywords
      content: Java 14, Java 15, record, text block, NullPointerException details, pattern matching, JEP
  - - meta
    - name: description
      content: Overview of key features of JDK 14/15, such as language enhancements such as records, text blocks, and null pointer precision hints.
---

##Java14

### Null pointer exception precise prompt

By adding `-XX:+ShowCodeDetailsInExceptionMessages` to the JVM parameters, you can obtain more detailed call information in null pointer exceptions and locate and solve problems faster.

```java
a.b.c.i = 99; // Assume that a null pointer will occur in this code
```

Before Java 14:

```java
Exception in thread "main" java.lang.NullPointerException
    at NullPointerExample.main(NullPointerExample.java:5)
```

After Java 14:

```java
 // The exception prompted after adding parameters clearly tells where the null result is
Exception in thread "main" java.lang.NullPointerException:
        Cannot read field 'c' because 'a.b' is null.
    at Prog.main(Prog.java:5)
```

### Enhancement of switch (converted)

The switch (preview feature) introduced in Java12 becomes the official version in Java14. There is no need to add parameters to enable it, and it can be used directly in JDK14.

Java12 introduces an execution block similar to lambda syntax for switch expressions after successful condition matching. There is no need to write more break. Java13 provides `yield` to return a value in the block.

```java
String result = switch (day) {
            case "M", "W", "F" -> "MWF";
            case "T", "TH", "S" -> "TTS";
            default -> {
                if(day.isEmpty())
                    yield "Please insert a valid day.";
                else
                    yield "Looks like a Sunday.";
            }

        };
System.out.println(result);
```

### Preview new features

#### record keyword

The `record` keyword can simplify the definition of **data class** (a Java class cannot be modified once it is instantiated). Use `record` instead of `class` to define a class. You only need to declare the attribute, and then you can get the access method of the attribute, as well as the `toString()`, `hashCode()`, `equals()` methods.

It is similar to using `class` to define a class, while using the lombok plug-in and annotating it with `@Getter, @ToString, @EqualsAndHashCode`.

```java
/**
 * This class has two characteristics
 * 1. All member attributes are final
 * 2. All methods consist of a constructor and two member attribute accessors (three in total)
 * Then this kind of class is very suitable to be declared using record
 */
final class Rectangle implements Shape {
    final double length;
    final double width;

    public Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }

    double length() { return length; }
    double width() { return width; }
}
/**
 * 1. The class declared using record will automatically have the three methods in the above class.
 * 2. On this basis, it also comes with equals(), hashCode() method and toString() method
 * 3. The toString method includes the string representation of all member attributes and their names
 */
record Rectangle(float length, float width) { }
```

#### Text block

In Java14, text blocks are still a preview feature, but two new escape characters are introduced:

- `\`: indicates the end of the line without introducing newline characters
- `\s`: represents a single space

```java
String str = "Wherever your heart goes, wherever you go, life is like traveling against the odds, sailing with a reed.";

String str2 = """
        Wherever your heart goes, wherever you go, \
        Life is like a journey against the odds, sailing with a reed. """;
System.out.println(str2);//Wherever the heart goes, life goes like a journey against the odds, sailing with a reed.
String text = """
        java
        c++\sphp
        """;
System.out.println(text);
//Output:
java
c++php
```

#### instanceof enhancement

It is still a **Preview Feature**, introduced in [Java 12 New Features](./java12-13.md).

### Others

- ZGC introduced from Java11 is the next generation GC algorithm after G1. From supporting the Linux platform to Java14, it starts to support MacOS and Windows (I personally feel that I can finally experience the effect of ZGC in daily development tools, although in fact G1 is enough)
- Removed CMS (Concurrent Mark Sweep) garbage collector (retired with success)
- Added the jpackage tool, which not only packages applications into jar packages as standard, but also supports feature packages for different platforms, such as `deb` and `rpm` under Linux, and `msi` and `exe` under the window platform.

##Java15

### CharSequence

The `CharSequence` interface adds a default method `isEmpty()` to determine if the character sequence is empty and return true if so.

```java
public interface CharSequence {
  default boolean isEmpty() {
      return this.length() == 0;
  }
}
```

### TreeMap

`TreeMap` introduces the following new methods:

- `putIfAbsent()`
- `computeIfAbsent()`
- `computeIfPresent()`
- `compute()`
- `merge()`

### ZGC(regular)

At the time of Java 11, ZGC was still in the experimental stage.

At that time, the emergence of ZGC allowed many Java developers to see another possibility for garbage collectors, so it attracted much attention.

After multiple versions of iterations, continuous improvements and problem fixes, ZGC is now officially available for use in Java 15!

However, the default garbage collector is still G1. You can start ZGC with the following parameters:

```bash
java -XX:+UseZGC className
```

### EdDSA (Digital Signature Algorithm)

A new digital signature algorithm based on Edwards-Curve Digital Signature Algorithm (EdDSA) with stronger security and performance has been added.

Although its performance is better than the existing ECDSA implementation, it will not completely replace the existing Elliptic Curve Digital Signature Algorithm (ECDSA) in the JDK.

```java
KeyPairGenerator kpg = KeyPairGenerator.getInstance("Ed25519");
KeyPair kp = kpg.generateKeyPair();

byte[] msg = "test_string".getBytes(StandardCharsets.UTF_8);

Signature sig = Signature.getInstance("Ed25519");
sig.initSign(kp.getPrivate());
sig.update(msg);
byte[] s = sig.sign();

String encodedString = Base64.getEncoder().encodeToString(s);
System.out.println(encodedString);
```

Output:

```plain
0Hc0lxxASZNvS52WsvnncJOH/mlFhnA8Tc6D/k5DtAX5BSsNVjtPF4R4+yMWXVjrvB2mxVXmChIbki6goFBgAg==```

### Text block (converted)

In Java 15, text blocks are an official feature.

### Hidden Classes

Hidden classes are designed for frameworks. Hidden classes cannot be directly used by the bytecode of other classes. They can only generate classes at runtime and use them indirectly through reflection.

### Preview new features

#### Sealed class

**Sealed Classes** is a new preview feature in Java 15.

Before there were sealed classes, in Java, if we wanted to prevent a class from being inherited and modified, we could use the `final` keyword to modify the class. However, this method is not very flexible and directly blocks the inheritance and modification channels of a class.

Sealed classes can restrict inheritance or the classes that implement them, so that this class can only be inherited by specified classes.

```java
// The abstract class Person only allows Employee and Manager to inherit.
public abstract sealed class Person
    permits Employee, Manager {

    //...
}
```

Additionally, any class that extends a sealed class must itself be declared `sealed`, `non-sealed`, or `final`.

```java
public final class Employee extends Person {
}

public non-sealed class Manager extends Person {
}
```

![](https://oss.javaguide.cn/javaguide/image-20210820153955587.png)

If the extended subclass and the closed class are allowed in the same source code file, the closed class does not need to use the permits statement. The Java compiler will retrieve the source file and add the permitted subclass to the closed class at compile time.

#### instanceof pattern matching

Java 15 has not adjusted this feature and continues to preview the feature, mainly to receive more usage feedback.

In future Java versions, Java aims to continue to improve the new `instanceof` pattern matching feature.

### Others

- **Nashorn JavaScript engine completely removed**: Nashorn is a JavaScript engine introduced from Java 8. Java 9 has made some enhancements to Nashorn and implemented some new features of ES6. It was deprecated in Java 11 and completely removed in Java 15.
- **DatagramSocket API refactor**
- **Disable and discard biased locking**: The introduction of biased locking increases the complexity of the JVM more than the performance improvement it brings. However, you can still use `-XX:+UseBiasedLocking` to enable biased locking, but it will prompt that this is a deprecated API.
-â€¦

<!-- @include: @article-footer.snippet.md -->