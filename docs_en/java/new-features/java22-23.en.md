---
title: Overview of new features in Java 22 & 23
category: Java
tag:
  - Java new features
head:
  - - meta
    - name: keywords
      content: Java 22, Java 23, JEP, Markdown documentation comments, class file API, vector API, structured concurrency, scope value
  - - meta
    - name: description
      content: Overview of key JEPs and language/platform enhancements in JDK 22/23, with ongoing tracking of performance and concurrency-related changes.
---

JDK 23 Like JDK 22, this is a non-LTS (Long Term Support) release and will only be supported by Oracle for six months. The next long-term support release is JDK 25, expected to be released in September next year.

The following figure shows the number of new features and update time brought by each version update from JDK8 to JDK 24:

![](https://oss.javaguide.cn/github/javaguide/java/new-features/jdk8~jdk24.png)

Since JDK 22 and JDK 23 have many overlapping new features, this article mainly introduces JDK 23, and will supplement some features unique to JDK 22.

JDK 23 has a total of 12 new features:

- [JEP 455: Primitive types, instanceof, and switch in patterns (preview)](https://openjdk.org/jeps/455)
- [JEP 456: Class File API (Second Preview)](https://openjdk.org/jeps/466)
- [JEP 467: Markdown Documentation Comments](https://openjdk.org/jeps/467)
- [JEP 469: Vector API (Eighth Incubation)](https://openjdk.org/jeps/469)
- [JEP 473: Stream Collector (Second Preview)](https://openjdk.org/jeps/473)
- [JEP 471: Deprecated memory access methods in sun.misc.Unsafe](https://openjdk.org/jeps/471)
- [JEP 474: ZGC: Default generational mode](https://openjdk.org/jeps/474)
- [JEP 476: Module Import Declaration (Preview)](https://openjdk.org/jeps/476)
- [JEP 477: Unnamed class and instance main methods (Third Preview)](https://openjdk.org/jeps/477)
- [JEP 480: Structured Concurrency (Third Preview)](https://openjdk.org/jeps/480)
- [JEP 481: Scoped Values (Third Preview)](https://openjdk.org/jeps/481)
- [JEP 482: Flexible Constructor Bodies (Second Preview)](https://openjdk.org/jeps/482)

The new features of JDK 22 are as follows:

![](https://oss.javaguide.cn/github/javaguide/java/new-features/jdk22-new-features.png)

Among them, I will single out the following three new features and introduce them in detail:

- [JEP 423: G1 Garbage Collector Area Fixed](https://openjdk.org/jeps/423)
- [JEP 454: External Functions and Memory API](https://openjdk.org/jeps/454)
- [JEP 456: Unnamed patterns and variables](https://openjdk.org/jeps/456)
- [JEP 458: Launching multi-file source code programs](https://openjdk.org/jeps/458)

## JDK 23

### JEP 455: Primitive types, instanceof, and switch in patterns (preview)

Prior to JEP 455, `instanceof` only supported reference types, and `switch` expressions and `case` labels of statements could only use integer literals, enumeration constants and string literals.

Among the preview features of JEP 455, `instanceof` and `switch` fully support all primitive types, including `byte`, `short`, `char`, `int`, `long`, `float`, `double`, `boolean`.

```java
//traditional writing
if (i >= -128 && i <= 127) {
    byte b = (byte)i;
    ... b ...
}

// Improve using instanceof
if (i instanceof byte b) {
    ... b ...
}

long v = ...;
//traditional writing
if (v == 1L) {
    // ...
} else if (v == 2L) {
    // ...
} else if (v == 10_000_000_000L) {
    // ...
}

// Use case labels of type long
switch (v) {
    case 1L:
        // ...
        break;
    case 2L:
        // ...
        break;
    case 10_000_000_000L:
        // ...
        break;
    default:
        // ...
}
```

### JEP 456: Class File API (Second Preview)

The class file API was first previewed in JDK 22, proposed by [JEP 457](https://openjdk.org/jeps/457).

The goal of the Class File API is to provide a standardized API for parsing, generating, and converting Java class files, replacing the past reliance on third-party libraries (such as ASM) for class file processing.

```java
//Create a ClassFile object, which is the entry point for operating class files.
ClassFile cf = ClassFile.of();
// Parse the byte array into ClassModel
ClassModel classModel = cf.parse(bytes);

// Build a new class file and remove all methods starting with "debug"
byte[] newBytes = cf.build(classModel.thisClass().asSymbol(),
        classBuilder -> {
            // Traverse all class elements
            for (ClassElement ce : classModel) {
                // Determine whether it is a method and the method name starts with "debug"
                if (!(ce instanceof MethodModel mm
                        && mm.methodName().stringValue().startsWith("debug"))) {
                    //Add to new class file
                    classBuilder.with(ce);
                }
            }
        });
```

### JEP 467: Markdown documentation comments

Markdown syntax can be used in JavaDoc documentation comments, instead of the original way of using only HTML and JavaDoc tags.

Markdown is more concise and easy to read, reducing the tediousness of manually writing HTML, while retaining support for HTML elements and JavaDoc tags. This enhancement is intended to make writing and reading API documentation comments easier without affecting the interpretation of existing comments. Markdown provides a simplified expression for common document elements (such as paragraphs, lists, links, etc.), improving the maintainability and developer experience of document comments.

![Markdown Documentation Comments](https://oss.javaguide.cn/github/javaguide/java/new-features/jep467-markdown-documentation-comments.png)

### JEP 469: Vector API (Eighth Incubation)

Vector calculations consist of a series of operations on vectors. The Vector API is used to express vector computations that can be reliably compiled at runtime into the best vector instructions on a supported CPU architecture, resulting in performance superior to equivalent scalar computations.

The goal of the Vector API is to provide users with a concise, easy-to-use, platform-independent way of expressing a wide range of vector computations.

This is a simple scalar calculation on array elements:

```java
void scalarComputation(float[] a, float[] b, float[] c) {
   for (int i = 0; i < a.length; i++) {
        c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;
   }
}
```

Here is the equivalent vector calculation using the Vector API:

```java
static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_PREFERRED;

void vectorComputation(float[] a, float[] b, float[] c) {
    int i = 0;
    int upperBound = SPECIES.loopBound(a.length);
    for (; i < upperBound; i += SPECIES.length()) {
        // FloatVector va, vb, vc;
        var va = FloatVector.fromArray(SPECIES, a, i);
        var vb = FloatVector.fromArray(SPECIES, b, i);
        var vc = va.mul(va)
                   .add(vb.mul(vb))
                   .neg();
        vc.intoArray(c, i);
    }
    for (; i < a.length; i++) {
        c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;
    }
}```

### JEP 473: Stream Collector (Second Preview)

The stream collector was first previewed in JDK 22, proposed by [JEP 461](https://openjdk.org/jeps/457).

This improvement allows the Stream API to support custom intermediate operations.

```java
source.gather(a).gather(b).gather(c).collect(...)
```

### JEP 471: Deprecated memory access methods in sun.misc.Unsafe

JEP 471 proposes deprecation of the memory access methods in `sun.misc.Unsafe` and these methods will be removed in a future version.

There are safe and efficient alternatives to these unsafe methods:

- `java.lang.invoke.VarHandle`: Introduced in JDK 9 (JEP 193), it provides a safe and efficient way to manipulate heap memory, including fields of objects, static fields of classes, and array elements.
- `java.lang.foreign.MemorySegment`: Introduced in JDK 22 (JEP 454), provides a safe and efficient way to access off-heap memory, sometimes working in conjunction with `VarHandle`.

These two classes are the core components of the Foreign Function & Memory API and are used to manage and operate off-heap memory respectively. The Foreign Function & Memory API was officially formalized in JDK 22 and became a standard feature.

```java
import jdk.incubator.foreign.*;
import java.lang.invoke.VarHandle;

// Class that manages off-heap integer arrays
class OffHeapIntBuffer {

    // VarHandle for accessing integer elements
    private static final VarHandle ELEM_VH = ValueLayout.JAVA_INT.arrayElementVarHandle();

    // memory manager
    private final Arena arena;

    // Off-heap memory segment
    private final MemorySegment buffer;

    // Constructor, allocates the specified amount of integer space
    public OffHeapIntBuffer(long size) {
        this.arena = Arena.ofShared();
        this.buffer = arena.allocate(ValueLayout.JAVA_INT, size);
    }

    // release memory
    public void deallocate() {
        arena.close();
    }

    //Set the value of the specified index volatilely
    public void setVolatile(long index, int value) {
        ELEM_VH.setVolatile(buffer, 0L, index, value);
    }

    //Initialize the elements in the specified range to 0
    public void initialize(long start, long n) {
        buffer.asSlice(ValueLayout.JAVA_INT.byteSize() * start,
                       ValueLayout.JAVA_INT.byteSize() * n)
              .fill((byte) 0);
    }

    //Copy the specified range of elements to a new array
    public int[] copyToNewArray(long start, int n) {
        return buffer.asSlice(ValueLayout.JAVA_INT.byteSize() * start,
                              ValueLayout.JAVA_INT.byteSize() * n)
                     .toArray(ValueLayout.JAVA_INT);
    }
}
```

### JEP 474: ZGC: Default generational mode

The default mode of the Z Garbage Collector (ZGC) is switched to generational mode, and non-generational mode is deprecated and is planned to be removed in a future release. This is because generational ZGC is a better choice in most scenarios.

### JEP 476: Module Import Declaration (Preview)

Module import declarations allow concise import of all exported packages of an entire module in Java code without having to declare the imports of the packages one by one. This feature simplifies the reuse of modular libraries, especially when using multiple modules, avoiding a large number of package import declarations, making it easier for developers to access third-party libraries and Java basic classes.

This feature is especially useful for beginners and prototype development, because it does not require developers to modularize their code, while retaining compatibility with traditional import methods, improving development efficiency and code readability.

```java
// Import the entire java.base module, developers can directly access List, Map, Stream and other classes without having to manually import related packages each time
import module java.base;

public class Example {
    public static void main(String[] args) {
        String[] fruits = { "apple", "berry", "citrus" };
        Map<String, String> fruitMap = Stream.of(fruits)
            .collect(Collectors.toMap(
                s -> s.toUpperCase().substring(0, 1),
                Function.identity()));

        System.out.println(fruitMap);
    }
}
```

### JEP 477: Unnamed class and instance main methods (Third Preview)

This feature mainly simplifies the declaration of the `main` method. For Java beginners, this declaration of the `main` method introduces too many Java syntax concepts, which is not conducive to beginners getting started quickly.

Define a `main` method before using this feature:

```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```

Define a `main` method after using this new feature:

```java
class HelloWorld {
    void main() {
        System.out.println("Hello, World!");
    }
}
```

Further simplification (unnamed classes allow us to omit the class name)

```java
void main() {
   System.out.println("Hello, World!");
}
```

### JEP 480: Structured Concurrency (Third Preview)

Java 19 introduces structured concurrency, a multi-threaded programming method. The purpose is to simplify multi-threaded programming through the structured concurrency API. It is not intended to replace `java.util.concurrent`. It is currently in the incubator stage.

Structured concurrency treats multiple tasks running in different threads as a single unit of work, simplifying error handling, improving reliability, and enhancing observability. That is, structured concurrency preserves the readability, maintainability, and observability of single-threaded code.

The basic API for structured concurrency is [`StructuredTaskScope`](https://download.java.net/java/early_access/loom/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/StructuredTaskScope.html). `StructuredTaskScope` supports splitting a task into multiple concurrent subtasks, executed in their own threads, and the subtasks must be completed before the main task can continue.

The basic usage of `StructuredTaskScope` is as follows:

```java
    try (var scope = new StructuredTaskScope<Object>()) {
        // Use the fork method to spawn a thread to perform subtasks
        Future<Integer> future1 = scope.fork(task1);
        Future<String> future2 = scope.fork(task2);
        // Wait for the thread to complete
        scope.join();
        // Handling of results may include handling or re-throwing exceptions
        ... process results/exceptions ...
    } // close
```结构化并发非常适合虚拟线程，虚拟线程是 JDK 实现的轻量级线程。许多虚拟线程共享同一个操作系统线程，从而允许非常多的虚拟线程。

### JEP 481：作用域值 （第三次预览）

作用域值（Scoped Values）可以在线程内和线程间共享不可变的数据，优于线程局部变量，尤其是在使用大量虚拟线程时。

```java
final static ScopedValue<...> V = new ScopedValue<>();

// In some method
ScopedValue.where(V, <value>)
           .run(() -> { ... V.get() ... call methods ... });

// In a method called directly or indirectly from the lambda expression
... V.get() ...
```

作用域值允许在大型程序中的组件之间安全有效地共享数据，而无需求助于方法参数。

### JEP 482：灵活的构造函数体（第二次预览）

这个特性最初在 JDK 22 由 [JEP 447: Statements before super(...) (Preview)](https://openjdk.org/jeps/447)提出。

Java 要求在构造函数中，`super(...)` 或 `this(...)` 调用必须作为第一条语句出现。这意味着我们无法在调用父类构造函数之前在子类构造函数中直接初始化字段。

灵活的构造函数体解决了这一问题，它允许在构造函数体内，在调用 `super(..)` 或 `this(..)` 之前编写语句，这些语句可以初始化字段，但不能引用正在构造的实例。这样可以防止在父类构造函数中调用子类方法时，子类的字段未被正确初始化，增强了类构造的可靠性。

这一特性解决了之前 Java 语法限制了构造函数代码组织的问题，让开发者能够更自由、更自然地表达构造函数的行为，例如在构造函数中直接进行参数验证、准备和共享，而无需依赖辅助方法或构造函数，提高了代码的可读性和可维护性。

```java
class Person {
    private final String name;
    private int age;

    public Person(String name, int age) {
        if (age < 0) {
            throw new IllegalArgumentException("Age cannot be negative.");
        }
        this.name = name; // 在调用父类构造函数之前初始化字段
        this.age = age;
        // ... 其他初始化代码
    }
}

class Employee extends Person {
    private final int employeeId;

    public Employee(String name, int age, int employeeId) {
        this.employeeId = employeeId; // 在调用父类构造函数之前初始化字段
        super(name, age); // 调用父类构造函数
        // ... 其他初始化代码
    }
}
```

## JDK 22

### JEP 423：G1 垃圾收集器区域固定

JEP 423 提出在 G1 垃圾收集器中实现区域固定（Region Pinning）功能，旨在减少由于 Java Native Interface (JNI) 关键区域导致的延迟问题。

JNI 关键区域内的对象不能在垃圾收集时被移动，因此 G1 以往通过禁用垃圾收集解决该问题，导致线程阻塞及严重的延迟。通过在 G1 的老年代和年轻代中引入区域固定机制，允许在关键区域内固定对象所在的内存区域，同时继续回收未固定的区域，避免了禁用垃圾回收的需求。这种改进有助于显著降低延迟，提升系统在与 JNI 交互时的吞吐量和稳定性。

### JEP 454：外部函数和内存 API

Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。

外部函数和内存 API 在 Java 17 中进行了第一轮孵化，由 [JEP 412](https://openjdk.java.net/jeps/412) 提出。Java 18 中进行了第二次孵化，由[JEP 419](https://openjdk.org/jeps/419) 提出。Java 19 中是第一次预览，由 [JEP 424](https://openjdk.org/jeps/424) 提出。JDK 20 中是第二次预览，由 [JEP 434](https://openjdk.org/jeps/434) 提出。JDK 21 中是第三次预览，由 [JEP 442](https://openjdk.org/jeps/442) 提出。

最终，该特性在 JDK 22 中顺利转正。

在 [Java 19 新特性概览](./java19.md) 中，我有详细介绍到外部函数和内存 API，这里就不再做额外的介绍了。

### JEP 456：未命名模式和变量

未命名模式和变量在 JDK 21 中由 [JEP 443](https://openjdk.org/jeps/443)提出预览，JDK 22 中就已经转正。

关于这个新特性的详细介绍，可以看看[Java 21 新特性概览(重要)](./java21.md)这篇文章中的介绍。

### JEP 458：启动多文件源代码程序

Java 11 引入了 [JEP 330：启动单文件源代码程序](https://openjdk.org/jeps/330)，增强了 `java` 启动器的功能，使其能够直接运行单个 Java 源文件。通过命令 `java HelloWorld.java`，Java 可以在内存中隐式编译源代码并立即执行，而不需要在磁盘上生成 `.class` 文件。这简化了开发者在编写小型工具程序或学习 Java 时的工作流程，避免了手动编译的额外步骤。

假设文件`Prog.java`声明了两个类：

```java
class Prog {
    public static void main(String[] args) { Helper.run(); }
}

class Helper {
    static void run() { System.out.println("Hello!"); }
}
```

`java Prog.java`命令会在内存中编译两个类并执行`main`该文件中声明的第一个类的方法。

这种方式有一个限制，程序的所有源代码必须放在一个`.java`文件中。

[JEP 458：启动多文件源代码程序](https://openjdk.org/jeps/458) 是对 JEP 330 功能的扩展，允许直接运行由多个 Java 源文件组成的程序，而无需显式的编译步骤。

假设一个目录中有两个 Java 源文件 `Prog.java` 和 `Helper.java`，每个文件各自声明了一个类：

```java
// Prog.java
class Prog {
    public static void main(String[] args) { Helper.run(); }
}

// Helper.java
class Helper {
    static void run() { System.out.println("Hello!"); }
}
```

当你运行命令 `java Prog.java` 时，Java 启动器会在内存中编译并执行 `Prog` 类的 `main` 方法。由于 `Prog` 类中的代码引用了 `Helper` 类，启动器会自动在文件系统中找到 `Helper.java` 文件，编译其中的 `Helper` 类，并在内存中执行它。这个过程是自动的，开发者无需显式调用 `javac` 来编译所有源文件。

这一特性使得从小型项目到大型项目的过渡更加平滑，开发者可以自由选择何时引入构建工具，避免在快速迭代时被迫设置复杂的项目结构。该特性消除了单文件的限制，进一步简化了从单一文件到多文件程序的开发过程，特别适合原型开发、快速实验以及早期项目的探索阶段。

