　　最近在备战面试的过程中，整理一下面试题。大多数题目都是自己手敲的，网上也有很多这样的总结。自己感觉总是很乱，所以花了很久把自己觉得重要的东西总结了一下。
## <font face="楷体">面向对象和面向过程的区别</font>
**面向过程：**
　　优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
缺点：没有面向对象易维护、易复用、易扩展
**面向对象：**
　　优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护
缺点：性能比面向过程低
## <font face="楷体">Java语言有哪些特点？</font>
　　1，简单易学；2，面向对象（封装，继承，多态）；3，平台无关性（Java虚拟机实现平台无关性）；4，可靠性；5，安全性；6，支持多线程（C++语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而Java语言却提供了多线程支持）；7，支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的，因此Java语言不仅支持网络编程而且很方便）；8，编译与解释并存；

## <font face="楷体">什么是字节码？采用字节码的最大好处是什么？什么Java是虚拟机？</font>
**先看下java中的编译器和解释器：**
 　　Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展名为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。
    Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令)---->jvm---->jvm中解释器----->机器可执行的二进制机器码---->程序运行。
**采用字节码的好处：**
　　Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。
## <font face="楷体">什么是Java虚拟机</font>
　　任何一种可以运行Java字节码的软件均可看成是Java的虚拟机（JVM）
## <font face="楷体">什么是Java程序的主类？应用程序和小程序的主类有何不同？</font>
　　一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main（）方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。
## <font face="楷体">什么是JDK?什么是JRE？</font>
　　JDK: 顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。
![JDK](https://user-gold-cdn.xitu.io/2017/11/8/9cf7f48fdbe608ae70080aa6c5a2f910?w=680&h=278&f=png&s=-1)
　　JRE:普通用户而只需要安装JRE（Java Runtime Environment）来 来运行Java程序。而程序开发者必须安装JDK来编译、调试程序。
## <font face="楷体">环境变量Path和ClassPath的作用是什么？如何设置这两个环境变量？</font>
Java环境变量PATH和CLASSPATH - 简书  http://www.jianshu.com/p/d63b099cf283
## <font face="楷体">Java应用程序与小程序之间有那些差别？</font>
简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。
## <font face="楷体">字符型常量和字符串常量的区别</font>
1) 形式上:
字符常量是单引号引起的一个字符 
字符串常量是双引号引起的若干个字符
2) 含义上:
字符常量相当于一个整形值(ASCII值),可以参加表达式运算
字符串常量代表一个地址值(该字符串在内存中存放位置)
3) 占内存大小
字符常量只占一个字节
字符串常量占若干个字节(至少一个字符结束标志)
## <font face="楷体">Java语言采用何种编码方案？有何特点？</font>
　　Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。

## <font face="楷体">构造器Constructor是否可被override</font>
　　在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以Constructor也就不能被override,但是可以overload,所以你可以看到一个类中有多个构造函数的情况。 

## <font face="楷体">重载和重写的区别</font>
　　重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。
　　重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写。
## <font face="楷体">java 面向对象编程三大特性------封装、继承、多态</font>

[https://blog.csdn.net/jianyuerensheng/article/details/51602015](https://blog.csdn.net/jianyuerensheng/article/details/51602015)

## <font face="楷体">java中equals方法的用法以及==的用法</font>

[http://www.cnblogs.com/bluestorm/archive/2012/03/02/2377615.html](http://www.cnblogs.com/bluestorm/archive/2012/03/02/2377615.html)

## <font face="楷体">String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？</font>

**可变性**
　

String类中使用字符数组保存字符串，private　final　char　value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[]value，这两种对象都是可变的。
　　

**线程安全性**

String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。
　　

**性能**

每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。
**对于三者使用的总结：** 
如果要操作少量的数据用 = String
单线程操作字符串缓冲区 下操作大量数据 = StringBuilder
多线程操作字符串缓冲区 下操作大量数据 = StringBuffer

## <font face="楷体">自动装箱与拆箱</font>
**装箱**：将基本类型用它们对应的引用类型包装起来；

**拆箱**：将包装类型转换为基本数据类型；
　　

Java使用自动装箱和拆箱机制，节省了常用数值的内存开销和创建对象的开销，提高了效率，由编译器来完成，编译器会在编译期根据语法决定是否进行装箱和拆箱动作。
## <font face="楷体">类、方法、成员变量和局部变量的可用修饰符 - </font>
 [http://blog.csdn.net/yttcjj/article/details/6939239](http://blog.csdn.net/yttcjj/article/details/6939239)

## <font face="楷体">在一个静态方法内调用一个非静态成员为什么是非法的？</font>
　　由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。

## <font face="楷体">在Java中定义一个不做事且没有参数的构造方法的作用</font>
　　Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。

## <font face="楷体">import java和javax有什么区别</font>
[http://www.cnblogs.com/EasonJim/p/6993139.html](http://www.cnblogs.com/EasonJim/p/6993139.html)
## <font face="楷体">接口和抽象类的区别是什么？</font>
1.接口的方法默认是public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法
2.接口中的实例变量默认是final类型的，而抽象类中则不一定
3.一个类可以实现多个接口，但最多只能实现一个抽象类
4.一个类实现接口的话要实现接口的所有方法，而抽象类不一定
5.接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象
从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。
## <font face="楷体">成员变量与局部变量的区别有那些？</font>
1. 从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；成员变量和局部变量都能被final所修饰；
2. 从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存
3. 从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
4. 成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。

## <font face="楷体">创建一个对象用什么运算符？对象实体与对象引用有何不同？</font>
　　new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）
## <font face="楷体">什么是方法的返回值？返回值在类的方法里的作用是什么？</font>
　　方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！
## <font face="楷体">一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</font>
　　主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。
## <font face="楷体">构造方法有哪些特性？</font>
　　1，名字与类名相同；2，没有返回值，但不能用void声明构造函数；3，生成类的对象时自动执行，无需调用。
## <font face="楷体">静态方法和实例方法有何不同？</font>
静态方法和实例方法的区别主要体现在两个方面： 

1. 在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 

2. 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制

## <font face="楷体">对象的相等与指向他们的引用相等，两者有什么不同？</font>
　　对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。

## <font face="楷体">在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</font>
　　帮助子类做初始化工作。
## <font face="楷体">什么是多态机制？Java语言是如何实现多态的？</font> 
[http://blog.csdn.net/bornlili/article/details/55213563](http://blog.csdn.net/bornlili/article/details/55213563)

## <font face="楷体">equals 和 == 的区别？</font> 
通俗点讲：==是看看左右是不是一个东西。equals是看看左右是不是长得一样。如何记住嘛。如果单纯是想记住，==：等于。equals：相同。两个长得一样的人，只能说长的相同(equals)，但是不等于他们俩是一个人。你只要记住equals，==就不用记了。

术语来讲的区别：1.==是判断两个变量或实例是不是指向同一个内存空间    equals是判断两个变量或实例所指向的内存空间的值是不是相同 
2.==是指对内存地址进行比较    equals()是对字符串的内容进行比较3.==指引用是否相同    equals()指的是值是否相同

**欢迎关注我的微信公众号（分享各种Java学习资源，面试题，以及企业级Java实战项目回复关键字免费领取）：**
![微信公众号](https://user-gold-cdn.xitu.io/2018/3/19/1623c870135a3609?w=215&h=215&f=jpeg&s=29172)
